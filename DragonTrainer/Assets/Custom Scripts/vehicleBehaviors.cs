using UnityEngine;
using System.Collections;
using System.Collections.Generic;
//ben version

/* This script will hopefully control the vehicles
 * in this project. This will include behaviors such
 * as seek, flee, and arrive */

abstract public class VehicleBehavior : MonoBehaviour {

    //some attributes common to vehicles
    public float maxSpeed = 10.0f;
    public float maxForce = 10.0f;
    public float mass = 1.0f;
    public float radius = 0.5f;
    public float gravity = 20.0f;

    //variables for wander
    float wanderRad = 4.0f;
    float wanderDist = 5.0f;
    float wanderRand = 1.0f;
    float wanderAng = 0.0f;

    protected CharacterController characterController;
    protected Vector3 acceleration;	//change in velocity per second
    protected Vector3 velocity;		//change in position per second
    protected Vector3 dv;           //desired velocity
    public Vector3 Velocity
    {
        get { return velocity; }
        set { velocity = value; }
    }

    //Classes that extend Vehicle must override CalcSteeringForce
    abstract protected void CalcSteeringForce();

	// Use this for initialization
	protected void Start () {
	    acceleration = Vector3.zero;
        /* Each vehicle contains a CharacterController which
		makes it easier to deal with the relationship between
		movement initiated by the character and the forces
		generated by contact with the terrain & other game objects.
		get component reference */
		characterController = gameObject.GetComponent<CharacterController> ();
	}
	
	// Update is called once per frame
	protected void Update () {
		CalcSteeringForce ();
		
		//update velocity
		velocity += acceleration * Time.deltaTime;
		velocity.y = 0;	// we are staying in the x/z plane
		velocity = Vector3.ClampMagnitude (velocity, maxSpeed);
		
		//orient the transform to face where we going
		if (velocity != Vector3.zero)
			transform.forward = velocity.normalized;
		
		// keep us grounded
		velocity.y -= gravity * Time.deltaTime;
		
		// the CharacterController moves us subject to physical constraints
		characterController.Move (velocity * Time.deltaTime);
		
		//reset acceleration for next cycle
		acceleration = Vector3.zero;

	}

    protected void ApplyForce (Vector3 steeringForce){
		acceleration += steeringForce/mass;
	}

    protected Vector3 Seek (Vector3 targetPos)
	{
		//find dv, desired velocity
		dv = targetPos - transform.position;		
		dv = dv.normalized * maxSpeed; 	//scale by maxSpeed
		dv -= velocity;
		dv.y = 0;					// only steer in the x/z plane
		return dv;
	}

    protected Vector3 Arrival (Vector3 targetPos)
	{
		Vector3 target_offset = targetPos - transform.position;
		float distance = target_offset.magnitude;
		float ramped_speed = maxSpeed * (distance / 4.0f);
		float clipped_speed = Mathf.Min(ramped_speed, maxSpeed);
		dv = (clipped_speed / distance) * target_offset;
		dv -= velocity;
		dv.y = 0;
		return dv;
	}

    // smoothed random walk -- just in case. Can be overwritten
	protected Vector3 Wander( ){
		Vector3 target = transform.position + transform.forward * wanderDist;
		wanderAng += Random.Range (-wanderRand, wanderRand);
		Quaternion rot = Quaternion.Euler(0, wanderAng, 0);
		Vector3 offset = rot * transform.forward;
		target += offset * wanderRad;
		return Seek (target);
	}

    // these last two methods are like alternate seek and flee
    protected Vector3 Pursue (GameObject F, float multiple)
	{
		//find dv, desired velocity
		Vector3 targetPos = F.transform.position + F.transform.forward;
		dv = targetPos - transform.position;		
		dv = dv.normalized * maxSpeed; 	//scale by maxSpeed
		dv -= velocity;
		dv.y = 0;					// only steer in the x/z plane
		return dv;
	}

	protected Vector3 Evade (GameObject F, float multiple)
	{
		//find dv, desired velocity
		Vector3 targetPos = F.transform.position + F.transform.forward;
		dv = targetPos - transform.position;		
		dv = dv.normalized * -maxSpeed; 	//scale by maxSpeed
		dv -= velocity;
		dv.y = 0;					// only steer in the x/z plane
		return dv;
	}

	// checks to see if the charcter is on a good path and corrects
	protected Vector3 FollowPath(GameObject F, Vector3 pathStart, Vector3 pathEnd, float pathWidth) {
		//print ("follow path called");

		// create a vector from path start to path end
		Vector3 pathDirection = pathEnd - pathStart;

		// find the (clockwise) perpendicular to that vector
		Vector3 pathPerp = new Vector3(pathDirection.z, 0 , -pathDirection.x);

		// find the next position of the vehicle
		Vector3 nextPos = F.transform.position + velocity * Time.deltaTime;

		// find a vector from the path to the pos
		Vector3 toPath = nextPos - pathEnd;
		// flatten
		toPath.y = 0;

		// find the shortest distance to the path using the perpendicular
		float d = Vector3.Dot(toPath,pathPerp);

		// use the distance's sign (+-) to determine which side of the line the point is on
		//float flipped = (d >=0) ? -1.0f : 1.0f;

		/* check to see if the distance from the next position of 
		 the vehicle to the line between the start and end is less
		 than the path width */
		if (Mathf.Abs(d) > pathWidth) {
			// if the vehicle will go off the path, push it back on

			// get a perpendicular that is scaled (this includes the minus)
			Vector3 sPathPerp = pathPerp.normalized * d;

			// seek the nearest point on the path
			Debug.DrawLine(transform.position,transform.position + -1*sPathPerp); // debug
			Debug.DrawLine(pathStart,pathEnd,Color.blue);
			Debug.DrawLine(pathStart,pathStart+pathPerp,Color.green);
			return Seek(transform.position + -1*sPathPerp);
		}



		// if the vehicle is on the path, do nothing
		return new Vector3(0,0,0);


		//Vector3 pathPerp = new Vector3((pathStart - pathEnd).x, 0, -1.0f * (pathStart - pathEnd).z);
		//pathPerp.Normalize();
		//Vector3 nextPos = F.transform.position + velocity * Time.deltaTime;
		//Vector3 flattened = (nextPos);
		//flattened.y = 0;
		//print ("perp: "); print(flattened);
		//float d = Vector3.Dot(flattened, -1.0f * pathPerp);
		//if (d < pathWidth && d > (-1)*pathWidth) {
			//print ("on path"); return new Vector3(0,0,0); 
		//} else {
			// seek the closest point on the line to where you will be
			//Vector3 t = pathPerp * d + transform.position;
			//print (t - F.transform.position);

		//}
	}

	protected Vector3 Align(Vector3 direction) {
		// push the object so that it aligns with the direction
		return direction.normalized - velocity.normalized;
	}

    protected Vector3 Avoid(GameObject obs, float safeDistance)
    {
        dv = Vector3.zero;
        float obRadius = 1.2f; // hard-coded for now, perhaps we'll change it
        safeDistance += obRadius;

        //vector from vehicle to center of obstacle
        Vector3 vecToCenter = obs.transform.position - transform.position;
        //eliminate y component so we have a 2D vector in the x, z plane
        vecToCenter.y = 0;

        // distance should not be allowed to be zero or negative because 
        // later we will divide by it and do not want to divide by zero
        // or cause an inadvertent sign change.
        float dist = Mathf.Max(vecToCenter.magnitude - obRadius - radius, 0.1f);

        // if too far to worry about, exit method
        if (dist > safeDistance)
            return Vector3.zero;

        //if behind us, exit method
        if (Vector3.Dot(vecToCenter, transform.forward) < 0)
            return Vector3.zero;

        float rightDotVTC = Vector3.Dot(vecToCenter, transform.right);

        //if we can pass safely, exit method
        if (Mathf.Abs(rightDotVTC) > radius + obRadius)
            return Vector3.zero;

        //if we get this far, than we need to steer

        //obstacle is on right so we steer to left
        if (rightDotVTC > 0)
            dv = transform.right * -maxSpeed * safeDistance / dist;
        else
            //obstacle on left so we steer to right
            dv = transform.right * maxSpeed * safeDistance / dist;

        dv -= velocity;    //calculate the steering force
        dv.y = 0;		   // only steer in the x/z plane
        return dv;
    }
}
